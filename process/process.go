package process

import "fmt"

// process to initializing until before consensus
func Process() {
	// statistic round number
	round++

	// create common nodes then print them information
	err := CreateNode()
	if err != nil {
		Debug()
	}
	//fmt.Print("\n----------------Initializing nodes---------------\n")
	//fmt.Println("\t\tinfo id votes \n")
	//waitingTime()
	//fmt.Println(nodePool)

	// select candidate from common node which have more votes
	fmt.Print("\n-------------Select candidate nodes...------------\n")
	fmt.Println("\t\tinfo id votes\n")
	waitingTime()
	SelectCandidate()
	Debug()
	//fmt.Print(nodePool[:candidateNum])

	// initial candidate node list
	fmt.Print("\n----------Initializing candidate nodes...----------\n")
	fmt.Println("\tinfo id votes auth d cl cv con bad good \n")
	waitingTime()
	InitCandidate()
	Debug()
	//fmt.Println(candPool)

	// simulate the auth
	fmt.Println("\n")
	fmt.Print("\n-------------------Authenticating-----------------\n")
	waitingTime()
	Auth()
	Debug()

	// simulate the vote
	fmt.Print("\n-----------------------Voting--------------------\n")
	waitingTime()
	Vote()
	Debug()

	// calculate the support degree
	fmt.Print("\n--------Calculate the candidates' support degree---------\n")
	waitingTime()
	CalSD()
	Debug()

	// selection delegate from candidate
	//nodes := SelectDelegate()
	fmt.Print("\n-----------------Select delegate nodes-----------------\n")
	fmt.Println("\tinfo id votes auth d cl cv con bad good \n")
	waitingTime()
	SelectDelegate(NUMBER)
	Debug()
	fmt.Println("\n")
	//fmt.Println(nodes)

	// initial consensus
	fmt.Print("\n---------------Initializing consensus...---------------\n")
	fmt.Println("\tinfo id votes auth d cl cv con un bad good addr\n")
	waitingTime()
	InitialDelegate(NUMBER)
	Debug()

	// old generate block version
	//waitingTime()
	//nodes := SelectDelegate()
	//for i := 0; i < len(nodes); i++ {
	//    if nodes[i].Auth == 1 {
	//        fmt.Printf("Block generated by candidate %d(delegate %d), which have authencated!\n", nodes[i].Id, i)
	//    } else {
	//        fmt.Printf("Block generated by candidate %d(delegate %d), which have unauthencated!\n", nodes[i].Id, i)
	//    }
}

// generate the block recurrently
func genLoop() {
	// create genesis block
	//first := genesisBlock()
	//lastBlock := first

	// generate the block
	fmt.Print("\n------------------------Generating block...-------------------------\n")
	waitingTime()
	nodes := SelectDelegate(NUMBER)
	for i := 0; i < len(nodes); i++ {
		if nodes[i].Auth == 1 {
			// TODO: think add block address with hash code
			fmt.Printf("Block generated by candidate %d(delegate %d), which have authencated!\n", nodes[i].Id, i)
		} else {
			fmt.Printf("Block generated by candidate %d(delegate %d), which have unauthencated!\n", nodes[i].Id, i)
		}

		// statistic continuity
		delePool[i].Con++
		//lastBlock = generateBlock(blockchain[i], fmt.Sprintf("block content"), "")
	}

	// validate the block then add it into the blockchain
	// FIXME: Is this one have necessity?
	blockHeight := len(blockchain)
	oldBlock := blockchain[blockHeight-1]
	newBlock := generateBlock(oldBlock, "block content", "")
	if isBlockValid(newBlock, oldBlock) {
		blockchain = append(blockchain, newBlock)
	}
}
